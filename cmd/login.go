package cmd

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"connectrpc.com/connect"
	libopsv1 "github.com/libops/api/proto/libops/v1"
	"github.com/libops/sitectl/pkg/api"
	"github.com/libops/sitectl/pkg/auth"
	"github.com/spf13/cobra"
)

var loginCmd = &cobra.Command{
	Use:   "login",
	Short: "Authenticate with the libops API",
	Long: `Authenticate with the libops API.

This command opens a browser window where you can choose to authenticate with:
- Google OAuth
- Email and password

After successful authentication, your credentials will be stored locally in ~/.sitectl/oauth.json.

Examples:
  sitectl login                                    # Open browser to login page
  sitectl login --api-url https://api.libops.io   # Use a custom API URL`,
	RunE: func(cmd *cobra.Command, args []string) error {
		flags := cmd.Flags()

		apiURL, err := flags.GetString("api-url")
		if err != nil {
			return fmt.Errorf("failed to get api-url flag: %w", err)
		}

		timeout, err := flags.GetDuration("timeout")
		if err != nil {
			return fmt.Errorf("failed to get timeout flag: %w", err)
		}

		// Create context with timeout
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		fmt.Println("Opening browser for authentication...")
		fmt.Println("You can choose to sign in with Google or email/password in the browser.")

		// Create unified OAuth client
		authClient := auth.NewAuthClient(apiURL)
		tokens, err := authClient.Login(ctx)
		if err != nil {
			return fmt.Errorf("authentication failed: %w", err)
		}

		// Save tokens to disk
		if err := auth.SaveTokens(tokens); err != nil {
			return fmt.Errorf("failed to save authentication credentials: %w", err)
		}

		tokenPath, _ := auth.TokenFilePath()
		fmt.Printf("\n✓ Successfully authenticated!\n")
		fmt.Printf("Credentials saved to: %s\n", tokenPath)

		// Display token expiry
		expiryTime := time.Unix(tokens.ExpiryDate, 0)
		fmt.Printf("Token expires: %s\n", expiryTime.Format(time.RFC1123))

		// Check if API key already exists
		keyPath := filepath.Join(os.Getenv("HOME"), ".sitectl", "key")
		if _, err := os.Stat(keyPath); err == nil {
			fmt.Printf("\nAPI key already exists at: %s\n", keyPath)
			return nil
		}

		// Prompt user to create API key
		fmt.Println("\n" + strings.Repeat("-", 60))
		fmt.Println("Would you like to create an API key for future authentication?")
		fmt.Println("This will allow you to skip the login flow in the future.")
		fmt.Print("Create API key? [y/N]: ")

		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			return fmt.Errorf("failed to read input: %w", err)
		}

		response = strings.TrimSpace(strings.ToLower(response))
		if response != "y" && response != "yes" {
			fmt.Println("Skipping API key creation")
			return nil
		}

		// Create API key
		fmt.Println("\nCreating API key...")
		keyName := fmt.Sprintf("sitectl_%s", time.Now().Format("2006-01-02_15-04-05"))

		client, err := api.NewLibopsAPIClient(ctx, apiURL)
		if err != nil {
			return fmt.Errorf("failed to create API client: %w", err)
		}

		resp, err := client.AccountService.CreateApiKey(ctx, connect.NewRequest(&libopsv1.CreateApiKeyRequest{
			Name:        keyName,
			Description: "Auto-generated by sitectl login",
			Scopes:      []string{}, // Full scope
		}))
		if err != nil {
			return fmt.Errorf("failed to create API key: %w", err)
		}

		// Save API key to ~/.sitectl/key
		if err := saveAPIKey(resp.Msg.ApiKey); err != nil {
			return fmt.Errorf("failed to save API key: %w", err)
		}

		fmt.Printf("\n✓ API key created successfully!\n")
		fmt.Printf("  Name: %s\n", keyName)
		fmt.Printf("  ID: %s\n", resp.Msg.ApiKeyId)
		fmt.Printf("  Stored at: %s\n", keyPath)
		fmt.Println("\nYou can now use sitectl commands without logging in again.")

		return nil
	},
}

// saveAPIKey saves the API key to ~/.sitectl/key with chmod 600
func saveAPIKey(apiKey string) error {
	homeDir := os.Getenv("HOME")
	if homeDir == "" {
		return fmt.Errorf("HOME environment variable not set")
	}

	sitectlDir := filepath.Join(homeDir, ".sitectl")
	if err := os.MkdirAll(sitectlDir, 0700); err != nil {
		return fmt.Errorf("failed to create .sitectl directory: %w", err)
	}

	keyPath := filepath.Join(sitectlDir, "key")
	if err := os.WriteFile(keyPath, []byte(apiKey), 0600); err != nil {
		return fmt.Errorf("failed to write key file: %w", err)
	}

	return nil
}

var logoutCmd = &cobra.Command{
	Use:   "logout",
	Short: "Remove local authentication credentials",
	Long: `Remove local authentication credentials.

This command removes the locally stored OAuth tokens from ~/.sitectl/oauth.json
and the API key from ~/.sitectl/key.
You will need to run 'sitectl login' again to authenticate.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		tokenPath, err := auth.TokenFilePath()
		if err != nil {
			return fmt.Errorf("failed to get token path: %w", err)
		}

		keyPath := filepath.Join(os.Getenv("HOME"), ".sitectl", "key")

		removedAny := false

		// Remove token file
		if _, err := os.Stat(tokenPath); err == nil {
			if err := auth.ClearTokens(); err != nil {
				return fmt.Errorf("failed to remove credentials: %w", err)
			}
			fmt.Printf("Removed OAuth tokens from: %s\n", tokenPath)
			removedAny = true
		}

		// Remove API key file
		if _, err := os.Stat(keyPath); err == nil {
			if err := os.Remove(keyPath); err != nil {
				return fmt.Errorf("failed to remove API key: %w", err)
			}
			fmt.Printf("Removed API key from: %s\n", keyPath)
			removedAny = true
		}

		if !removedAny {
			fmt.Println("No authentication credentials found")
			return nil
		}

		fmt.Println("\n✓ Successfully logged out")

		return nil
	},
}

var whoamiCmd = &cobra.Command{
	Use:   "whoami",
	Short: "Display current authentication status",
	Long: `Display current authentication status and token information.

This command shows information about your current authentication session,
including token expiry and whether you need to re-authenticate.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		tokens, err := auth.LoadTokens()
		if err != nil {
			fmt.Println("Not authenticated")
			fmt.Println("Run 'sitectl login' to authenticate")
			return nil
		}

		fmt.Println("Authentication Status: ✓ Authenticated")
		fmt.Printf("Token Type: %s\n", tokens.TokenType)

		expiryTime := time.Unix(tokens.ExpiryDate, 0)
		fmt.Printf("Token Expires: %s\n", expiryTime.Format(time.RFC1123))

		if tokens.IsTokenExpired() {
			fmt.Println("\n⚠ Token has expired")
			fmt.Println("Run 'sitectl login' to re-authenticate")
		} else {
			timeUntilExpiry := time.Until(expiryTime)
			fmt.Printf("Time Until Expiry: %s\n", timeUntilExpiry.Round(time.Minute))
		}

		if tokens.Scope != "" {
			fmt.Printf("Scopes: %s\n", tokens.Scope)
		}

		tokenPath, _ := auth.TokenFilePath()
		fmt.Printf("\nCredentials stored at: %s\n", tokenPath)

		return nil
	},
}

func init() {
	// Login command flags
	loginCmd.Flags().Duration("timeout", 5*time.Minute, "Timeout for authentication flow")

	RootCmd.AddCommand(loginCmd)
	RootCmd.AddCommand(logoutCmd)
	RootCmd.AddCommand(whoamiCmd)
}
